# The oss-fuzz infrastructure #

# How we use it #

For fuzzing purposes, we use _vsprintf_ to format the output to a
static buffer.  This is because during the
fuzzing process, we sometimes get *EINTR* if writing to stdout.
However, in order to replicate a crash, it can help to see what the
printer was doing before it crashed, so if you set the environment
variable *TCPDUMP_PRINT* to any value before running the replicator,
the printer will print to stdout.  If you set the environment
variable *REPLICATE_TRUNCATE* to any value before running the
replicator, the code will try the given packet and all prefixes
(to try to find additional related truncated-packet problems).

# Reproducing a crash using an example #

The binaries that we build in this directory can take a data file
as generated by the fuzzing infrastructure and run it through the
same function.  If you don't understand the output from the
sanitizer that oss-fuzz provides, you can run again using valgrind:

    ~/src/tcpdump/fuzzing @us157.sjc> TCPDUMP_PRINT=1 valgrind ./ether_print_fuzzer ../../oss-fuzz/build/out/tcpdump/crash-20aa211fc54fda2cca155539d1d5189990e6bd4e
    ==2963== Memcheck, a memory error detector
    ==2963== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
    ==2963== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
    ==2963== Command: ./ether_print_fuzzer ../../oss-fuzz/build/out/tcpdump/crash-20aa211fc54fda2cca155539d1d5189990e6bd4e
    ==2963== 
    StandaloneFuzzTargetMain: running 1 inputs
    Running: ../../oss-fuzz/build/out/tcpdump/crash-20aa211fc54fda2cca155539d1d5189990e6bd4e
    ==2963== Invalid read of size 1
    ==2963==    at 0x454E26: rpl_dio_printopt (print-icmp6.c:665)
    ==2963==    by 0x456C7F: rpl_dio_print (print-icmp6.c:714)
    ==2963==    by 0x456C7F: rpl_print (print-icmp6.c:839)
    ==2963==    by 0x456C7F: icmp6_print (print-icmp6.c:1148)
    ==2963==    by 0x4103EB: ip6_print (print-ip6.c:351)
    ==2963==    by 0x40C599: ethertype_print (print-ether.c:370)
    ==2963==    by 0x40CCCD: ether_print (print-ether.c:237)
    ==2963==    by 0x403AAF: LLVMFuzzerTestOneInput (in /home/fenner/src/tcpdump/fuzzing/ether_print_fuzzer)
    ==2963==    by 0x403D75: main (in /home/fenner/src/tcpdump/fuzzing/ether_print_fuzzer)
    ==2963==  Address 0x5d24b1c is 0 bytes after a block of size 156 alloc'd
    ==2963==    at 0x4C2AC36: malloc (vg_replace_malloc.c:299)
    ==2963==    by 0x403D12: main (in /home/fenner/src/tcpdump/fuzzing/ether_print_fuzzer)
    ==2963== 
    Done:    ../../oss-fuzz/build/out/tcpdump/crash-20aa211fc54fda2cca155539d1d5189990e6bd4e: (156 bytes)
    IP6 truncated-ip6 - 4962 bytes missing!(class 0x10, hlim 58, next-header ICMPv6 (58) payload length: 14906) 793a:3a3a:3a3a:28ab:ab00:: > ce:dada:dada:dada:dada:dada:dada:9b9b: ICMP6, RPL, (CLR)DODAG Information Object [dagid:4ff:ffff:ffff:fffe:a08:d5:dada:8e61,seq:5,instance:255,rank:65344,mop:mop4,prf:4] opt:subopt:113 len:2  opt:destprefix len:7  opt:subopt:52 len:54  opt:subopt:255 len:4  opt:subopt:7 len:2  opt:pad0 opt:pad0==2963== 

and, of course, when the bug is fixed you can validate it using the
same sequence.

# Reproducing a crash inside the oss-fuzz infrastructure #

    ~/src/oss-fuzz @us157.sjc> python infra/helper.py reproduce -e TCPDUMP_PRINT=1 tcpdump ether_print_fuzzer build/out/tcpdump/crash-20aa211fc54fda2cca155539d1d5189990e6bd4e

# Turning the example into a pcap #

Of course, the tcpdump regression tests use pcap files as input.
When the oss-fuzz framework creates a replication example, it is
the raw data that the specific fuzzer accepts (see below).  The
script `corpus/corpus2pcap` converts an example into a pcap, using
a heuristic as to what type of packet it is.  (E.g., if it starts
with 16 0xff's, then it's a BGP packet; if it starts with 0x45 then
it is an IPv4 packet).  If it guesses wrong, there is a `--type`
argument to tell it what the type of the input is.

# When fixing a bug found by this infrastructure #

Remember to assign credit to "OSS-Fuzz"

# ip\_print\_fuzzer #

## Input ##

The ip\_print\_fuzzer takes an IPv4 packet as input.

## Corpus ##

The `pcap2corpus` run extracts all IPv4 packets from tests/\*.pcap
into the ip\_print\_fuzzer\_seed\_corpus.zip

# ip6\_print\_fuzzer #

## Input ##

The ip6\_print\_fuzzer takes an IPv6 packet as input.

## Corpus ##

The `pcap2corpus` run extracts all IPv6 packets from tests/\*.pcap
into the ip6\_print\_fuzzer\_seed\_corpus.zip

# bgp\_print\_fuzzer #

## Input ##

The bgp\_print\_fuzzer takes a BGP message, starting with marker,
as input.

## Corpus ##

The `pcap2corpus` run extracts all BGP TCP payloads from tests/\*.pcap
into the bgp\_print\_fuzzer\_seed\_corpus.zip

TODO: It would be nice to also extract individual messages split at the
marker, to allow TCP payloads with multiple BGP messages to be parsed
as individual BGP messages.

TODO: write a tool that takes MRT dump in and outputs every BGP message
to an individual file

# ether\_print\_fuzzer #

## Input ##

The ether\_print\_fuzzer takes an Ethernet packet, starting with
14-byte header, as input.

## Corpus ##

The `pcap2corpus` run extracts all Ethernet packets that do not match
a more-specific type above into the ether\_print\_fuzzer\_seed\_corpus.zip

